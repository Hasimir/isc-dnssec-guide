<section id="validation-easy-start-explained">
 <title>Validation Easy Start Explained</title>
 <para>In <xref linkend="easy-start-guide-for-recursive-servers"/>, we used two lines of configuration to turn on DNSSEC validation. Now we are going to take a closer look at what it actually does, and some other options.</para>

 <!-- dnssec-enable -->
 <section id="dnssec-enable-explained">
  <title>dnssec-enable</title>
  <screen>options {
    dnssec-enable yes;
};</screen>

  <para>This line enables DNSSEC support, the default is yes, we're declaring it explicitly here. Note that if this is the only thing you enable and nothing else, the default validation behavior is set to rely on manual keys, and no validation will actually take place until you have manually configured at least one <code>trusted-key</code>.</para>
 </section>

 <!-- dnssec-validation -->
 <section id="dnssec-validation-explained">
  <title>dnssec-validation</title>
  <screen>options {
    dnssec-validation auto;
};</screen>

  <para>This line enables DNSSEC validation in named, and it will automatically get a key on file. Note <code>dnssec-enable</code> also needs to be set to yes to be effective (which by default it is). There are three possible choices:

   <itemizedlist>
    <listitem>
     <simpara><emphasis>yes</emphasis>: DNSSEC validation is enabled, but a trust anchor must be manually configured. This is the default.</simpara>
    </listitem>

    <listitem>
     <simpara><emphasis>no</emphasis>: DNSSEC validation is disabled, and recursive server will behave in the "old fashioned" way of performing insecure DNS lookups.</simpara>
    </listitem>

    <listitem>
     <simpara><emphasis>auto</emphasis>: DNSSEC validation is enabled, and a default trust anchor (included as part of BIND) for the DNS root zone is used.</simpara>
    </listitem>
   </itemizedlist>
  </para>

  <para>Let’s discuss the difference between <code>yes</code> and <code>auto</code>. If you set it to <code>yes</code> (the default), the trust anchor will need to be manually defined and maintained using the <code>trusted-key</code> statement in the configuration file; if you set it to <code>auto</code> (as shown in the example), then no further action should be required as BIND includes a copy<footnote><para>BIND technically includes two copies of the root key, one is in <code>bind.keys.h</code> and is built into the executable, and one is in <code>bind.keys</code> as a <code>managed-key</code> statement. The two copies of the key are identical.</para></footnote> of the root key. When set to <code>auto</code>, BIND will automatically keep the keys up-to-date without intervention from the DNS administrator.</para>
  
  <para>To learn more about trust anchors, please refer to <xref linkend="trusted-keys-and-managed-keys"/>.</para>
 </section>


 <!-- === How Does DNSSEC Change DNS Lookup (Revisited) === -->
 <section id="how-does-dnssec-change-dns-lookup-revisited">
  <title>How Does DNSSEC Change DNS Lookup (Revisited)?</title>
  <para>So by now you’ve enabled validation on your recursive name server, and verified that it works. What exactly changed? In <xref linkend="how-does-dnssec-change-dns-lookup"/> we looked at the very high level, simplified 12-steps of DNSSEC validation process. Let’s revisit that process now and see what your validating resolver is doing in more details. Again, we are using the example to lookup the A record for the domain name www.isc.org:</para>
  <para>
  <imagedata fileref="../img/image-placeholder.jpg"/>
  <orderedlist>
   <!-- #1 -->
   <listitem>
    <simpara>Validating resolver queries the name server for isc.org for the A record of <code>www.isc.org</code>. This query has the <code>DNSSEC OK</code> (<code>do</code>) bit set to 1, notifying the remote authoritative server that DNSSEC answers are desired.</simpara>
   </listitem>

   <!-- #2 -->
   <listitem>
    <simpara>The zone <code>isc.org</code> is signed, and its name servers are DNSSEC-aware, thus it responds the answer to the A record query plus the RRSIG for the A record.</simpara>
   </listitem>

   <!-- #3 -->
   <listitem>
	<simpara>Validating resolver queries for the DNSKEY for <code>isc.org</code>.</simpara>
   </listitem>

   <!-- #4 -->
   <listitem>
    <simpara><code>isc.org</code> name server responds with the DNSKEY and RRSIG records. The DNSKEY is used to verify the answers received in #2.</simpara>
   </listitem>

   <!-- #5 -->
   <listitem>
	<simpara>Validating resolver queries the parent (<code>.org</code>) for the DS record for <code>isc.org</code>.</simpara>
   </listitem>

   <!-- #6 -->
   <listitem>
	<simpara><code>.org</code> name server responds with the DS and RRSIG records. The DS record is used to verify the answers received in #4.</simpara>
   </listitem>

   <!-- #7 -->
   <listitem>
	<simpara>Validating resolver queries for the DNSKEY for <code>.org</code>.</simpara>
   </listitem>

   <!-- #8 -->
   <listitem>
    <simpara><code>.org</code> name server responds with DNSKEY and RRSIG. The DNSKEY is used to verify the answers received in #6.</simpara>
   </listitem>

   <!-- #9 -->
   <listitem>
    <simpara>Validating resolver queries the parent (root) for the DS record for <code>.org</code>.</simpara>
   </listitem>

   <!-- #10 -->
   <listitem>
    <simpara>Root name server responds with DS and RRSIG records. The DS record is used to verify the answers received in #8.</simpara>
   </listitem>

   <!-- #11 -->
   <listitem>
    <simpara>Validating resolver queries for the DNSKEY for root.</simpara>
   </listitem>

   <!-- #12 -->
   <listitem>
    <simpara>Root name server responds with DNSKEY and RRSIG. The DNSKEY is used to verify the answers received in #10.</simpara>
   </listitem>
  </orderedlist></para>

  <para>Just like in <xref linkend="how-does-dnssec-change-dns-lookup"/>, after step #12, the validating resolver takes the DNSKEY received and compares to the key or keys it has configured. These configured keys are also known as trust anchors, and that is what we will talk about next in <xref linkend="trust-anchors"/>.</para>
 </section>
</section>
