<section id="validation-easy-start-explained">
 <title>Validation Easy Start Explained</title>
 <para>In <xref linkend="easy-start-guide-for-recursive-servers"/>, we used two lines of configuration to turn on DNSSEC validation. Now we are going to take a closer look at what it actually does, and some other options.</para>

 <!-- dnssec-enable -->
 <section id="dnssec-enable-explained">
  <title>dnssec-enable</title>
  <screen>options {
    dnssec-enable yes;
};</screen>
  <para>This line enables DNSSEC support in named. Unless set to yes, named behaves as if it does not support DNSSEC. The default is yes. Note that if this is the only thing you enable, the default validation behavior is set to rely on manual keys (which is not included), and no validation will actually take place until you have configured a <code>trusted-key</code>.</para>
 </section>

 <!-- dnssec-validation -->
 <section id="dnssec-validation-explained">
  <title>dnssec-validation</title>
  <screen>options {
    dnssec-validation auto;
};</screen>

  <para>This line enables DNSSEC validation in named, and it will automatically get a key on file. Note <code>dnssec-enable</code> also needs to be set to yes to be effective (which by default it is). There are three possible choices:

   <itemizedlist>
    <listitem>
     <simpara><emphasis>yes</emphasis>: DNSSEC validation is enabled, but a trust anchor must be manually configured. This is the default.</simpara>
    </listitem>

    <listitem>
     <simpara><emphasis>no</emphasis>: DNSSEC validation is disabled, and recursive server will behave in the "old fashioned" way of performing insecure DNS lookups.</simpara>
    </listitem>

    <listitem>
     <simpara><emphasis>auto</emphasis>: DNSSEC validation is enabled, and a default trust anchor (included as part of BIND) for the DNS root zone is used.</simpara>
    </listitem>
   </itemizedlist>
  </para>

  <para>Let's discuss the difference here between <code>yes</code> and <code>auto</code>. If you set it to <code>yes</code> (the default), the trust anchor will need to be manually defined and maintained using the <code>trusted-key</code> statement in the configuration file; if you set it to <code>auto</code> (as shown in the example), then the <code>managed-key</code> statement is used, to automatically keep the keys up-to-date without intervention from the DNS administrator.</para>
  
  <para>To learn more about trust anchors, please refer to <xref linkend="trusted-keys-and-managed-keys"/>.</para>
 </section>


 <!-- === How Does DNSSEC Change DNS Lookup (Revisited) === -->
 <section id="how-does-dnssec-change-dns-lookup-revisited">
  <title>How Does DNSSEC Change DNS Lookup (Revisited)?</title>
  <para>So by now you’ve enabled validation on your recursive name server, and verified that it works. What exactly changed? In <xref linkend="how-does-dnssec-change-dns-lookup"/> we looked at the very high level, simplified 12-steps of DNSSEC validation process. Let’s revisit that process now and see what your validating resolver is doing in more details. Again, we are using the example to lookup the A record for the domain name www.isc.org:</para>
  <para>
  <imagedata fileref="../img/image-placeholder.jpg"/>
  <orderedlist>
   <!-- #1 -->
   <listitem>
    <simpara>Validating resolver queries the name server for isc.org for the A record of www.isc.org. This query has the DNSSEC OK (do) bit set to 1, notifying the remote authoritative server that DNSSEC answers are desired.</simpara>
   </listitem>

   <!-- #2 -->
   <listitem>
    <simpara>The zone isc.org is signed, and its name servers are DNSSEC-aware, thus it responds the answer to the A record query plus the RRSIG for the A record.</simpara>
   </listitem>

   <!-- #3 -->
   <listitem>
	<simpara>Validating resolver queries for the DNSKEY for isc.org</simpara>
   </listitem>

   <!-- #4 -->
   <listitem>
    <simpara>isc.org name server responds with the DNSKEY and RRSIG records. The DNSKEY is used to verify the RRSIG received in #2</simpara>
   </listitem>

   <!-- #5 -->
   <listitem>
	<simpara>Validating resolver queries the parent (.org) for the DS record for isc.org.</simpara>
   </listitem>

   <!-- #6 -->
   <listitem>
	<simpara>.org name server responds with the DS and RRSIG records. The DS record is used to verify the DNSKEY and RRSIG received in #4</simpara>
   </listitem>

   <!-- #7 -->
   <listitem>
	<simpara>Validating resolver queries for the DNSKEY for .org</simpara>
   </listitem>

   <!-- #8 -->
   <listitem>
    <simpara>.org name server responds with DNSKEY and RRSIG. The DNSKEY is used to verify the RRSIG received in #6.</simpara>
   </listitem>

   <!-- #9 -->
   <listitem>
    <simpara>Validating resolver queries the parent (root) for the DS record for .org.</simpara>
   </listitem>

   <!-- #10 -->
   <listitem>
    <simpara>Root name server responds with DS and RRSIG records. The DS record is used to verify the DNSKEY and RRSIG received in #8.</simpara>
   </listitem>

   <!-- #11 -->
   <listitem>
    <simpara>Validating resolver queries for the DNSKEY for root.</simpara>
   </listitem>

   <!-- #12 -->
   <listitem>
    <simpara>Root name server responds with DNSKEY and RRSIG. The DNSKEY is used to verify the RRSIG received in #10.</simpara>
   </listitem>
  </orderedlist></para>

  <para>Just like in <xref linkend="how-does-dnssec-change-dns-lookup"/>, after step #12, the validating resolver takes the DNSKEY received and compares to the key it has stored on file.  This key-on-file is called a trust anchor, and that is what we will talk about next.</para>
 </section>
</section>
